#!/bin/bash

TMP_FILE="/tmp/ivim_buffer.txt"
CONVERSATION_FILE="/tmp/ivim_conversation_$(date "+%Y%m%d%H%M%S").json"
VERBOSITY=0

# Logging function
log() {
  local level="$1"
  local message="$2"
  local level_num

  case "$level" in
    ERROR) level_num=0 ;;
    WARN)  level_num=1 ;;
    INFO)  level_num=2 ;;
    DEBUG) level_num=3 ;;
    *)     echo "Unknown log level: $level"; exit 1 ;;
  esac

  if [[ $VERBOSITY -ge $level_num ]]; then
    echo "[$level] $message"
  fi
}

# Parse options for verbosity level
while getopts "v" opt; do
    case $opt in
        v) VERBOSITY=$((VERBOSITY+1)) ;;
        \?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
    esac
done

# Function to initialize the conversation file if it doesn't exist
initialize_conversation() {
    log INFO "Initializing conversation file."
    echo '[{"role": "system", "content": "You are a helpful assistant."}]' > "$CONVERSATION_FILE"
    log DEBUG "Conversation file content initialized."
}

# Function to route command through the Command Router
route_command() {
    local user_input="$1"
    echo "$user_input" | commandrouter
}

# Function to invoke the appropriate microservice based on the route
invoke_service() {
    local service_name="$1"
    local command="$2"
    "/path/to/${service_name}" "$command"
}

# Main interaction loop
interact() {
    if [ ! -f "$CONVERSATION_FILE" ]; then
        log WARN "Conversation file not found."
        initialize_conversation
    fi

    while true; do
        log INFO "Provide your message or type 'exit' to quit:"
        read -r user_input
        log DEBUG "Read user input: $user_input"

        if [[ "$user_input" == "exit" ]]; then
            log INFO "Exiting."
            break
        fi

        log DEBUG "Routing command through the Command Router."
        service_name=$(route_command "$user_input")

        log DEBUG "Invoking the $service_name service."
        response=$(invoke_service "$service_name" "$user_input")
        log DEBUG "Service response: $response"

        log DEBUG "Appending user input and response to conversation."
        conversation_json=$(<"$CONVERSATION_FILE")
        updated_conversation=$(echo "$conversation_json" | jq --arg user_input "$user_input" --arg response "$response" '. += [{"role": "user", "content": $user_input}, {"role": "assistant", "content": $response}]')
        echo "$updated_conversation" > "$CONVERSATION_FILE"
        log DEBUG "Updated conversation saved to file."
    done
}

# Start the main interaction loop
log INFO "Starting interaction loop."
interact
